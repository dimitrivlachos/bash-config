# Colored logging functions
# Color codes for consistent messaging
BC_COLOR_RED='\033[0;31m'
BC_COLOR_GREEN='\033[0;32m'
BC_COLOR_YELLOW='\033[1;33m'
BC_COLOR_BLUE='\033[0;34m'
BC_COLOR_CYAN='\033[0;36m'
BC_COLOR_GRAY='\033[0;37m'
BC_COLOR_RESET='\033[0m'

# Logging functions with colors
bc_log_error() {
  echo -e "${BC_COLOR_RED}❌ [ERROR]${BC_COLOR_RESET} $*" >&2
}

bc_log_warn() {
  echo -e "${BC_COLOR_YELLOW}⚠️  [WARN]${BC_COLOR_RESET} $*" >&2
}

bc_log_info() {
  echo -e "${BC_COLOR_BLUE}ℹ️  [INFO]${BC_COLOR_RESET} $*" >&2
}

bc_log_success() {
  echo -e "${BC_COLOR_GREEN}✅ [SUCCESS]${BC_COLOR_RESET} $*" >&2
}

bc_log_debug() {
  [[ "${BASH_CONFIG_DEBUG:-}" == "true" ]] && echo -e "${BC_COLOR_GRAY}🔍 [DEBUG]${BC_COLOR_RESET} $*" >&2
}

# Local activate helper
mae() {
  local env_name="${1:-ENV}"
  local env_path=""

  if [ -d "./$env_name" ]; then
    env_path="$(pwd)/$env_name"
  elif [ -d "../$env_name" ]; then
    env_path="$(cd .. && pwd)/$env_name"
  else
    bc_log_error "No environment '$env_name' found in current or parent directory."
    return 1
  fi

  if command -v micromamba &>/dev/null; then
    micromamba activate "$env_path"
  elif command -v mamba &>/dev/null; then
    mamba activate "$env_path"
  else
    bc_log_error "Neither micromamba nor mamba found in PATH."
    return 1
  fi
}

# fastfetch wrapper that allows specialisations to override binary and config
bc_ff() {
  local ff_bin="${FASTFETCH_BIN:-fastfetch}" # Use override if set, otherwise system
  local ff_config="${FASTFETCH_CONFIG:-}"

  # Check if fastfetch is installed
  if command -v "$ff_bin" &>/dev/null; then
    # Check if config file is set and exists
    if [[ -n "$ff_config" && -f "$ff_config" ]]; then
      # Run fastfetch with the specified config
      "$ff_bin" --config "$ff_config" 2>/dev/null
    else
      # Run fastfetch without a config file
      "$ff_bin" 2>/dev/null
    fi
  else
    # Echo error to stderr (>&2)
    # and return non-zero exit code to indicate failure
    bc_log_error "[fastfetch] binary not found: $ff_bin"
    return 1
  fi
}

# Backward compatibility alias
ff() { bc_ff "$@"; }

# SSH agent management functions

# Check if a specific SSH key is loaded in the agent
bc_is_ssh_key_loaded() {
  local key_file="$1"
  if [[ -z "$key_file" || ! -f "$key_file" ]]; then
    return 1
  fi
  
  local key_fingerprint
  key_fingerprint=$(ssh-keygen -lf "$key_file" 2>/dev/null | awk '{print $2}')
  [[ -n "$key_fingerprint" ]] && ssh-add -l 2>/dev/null | grep -q "$key_fingerprint"
}

# Start a new SSH agent and save info to file
bc_start_ssh_agent() {
  local agent_file="$1"
  eval "$(ssh-agent -s)" >&2
  echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK; export SSH_AUTH_SOCK;" > "$agent_file"
  echo "SSH_AGENT_PID=$SSH_AGENT_PID; export SSH_AGENT_PID;" >> "$agent_file"
}

# Clean up orphaned SSH agents
# This function cleans up agents when necessary to avoid killing working
# agents that other terminals might be using
bc_cleanup_ssh_agents() {
  local agent_file="${1:-$HOME/.ssh-agent-info}"
  local current_agents
  local stored_pid
  local keep_stored_agent=false
  
  # First, check if we have a stored agent that's still working
  if [[ -f "$agent_file" ]]; then
    # Extract PID
    stored_pid=$(grep "SSH_AGENT_PID=" "$agent_file" 2>/dev/null | cut -d'=' -f2 | cut -d';' -f1 | tr -d ' ')
    
    # Test if the stored agent is still accessible
    if [[ -n "$stored_pid" ]]; then
      # Temporarily load the stored agent's environment
      source "$agent_file" >/dev/null 2>&1
      
      # If we can successfully list keys, the agent is working
      if ssh-add -l >/dev/null 2>&1; then
        bc_log_debug "Stored agent (PID: $stored_pid) is still accessible"
        keep_stored_agent=true
      else
        bc_log_debug "Stored agent (PID: $stored_pid) is not accessible, marking for cleanup"
        # Remove the stale agent info file
        rm -f "$agent_file"
      fi
    fi
  fi
  
  # Get all running ssh-agent processes for this user
  mapfile -t current_agents < <(pgrep -u "$USER" ssh-agent 2>/dev/null)
  
  if [[ "$keep_stored_agent" == "true" ]]; then
    # Keep the working stored agent, clean up others
    bc_log_debug "Cleaning up other agents while keeping stored agent (PID: $stored_pid)"
    local killed_count=0
    for pid in "${current_agents[@]}"; do
      if [[ "$pid" != "$stored_pid" ]]; then
        if kill "$pid" 2>/dev/null; then
          bc_log_info "Cleaned up redundant ssh-agent (PID: $pid)"
          ((killed_count++))
        fi
      fi
    done
    [[ $killed_count -gt 0 ]] && bc_log_success "Cleaned up $killed_count redundant ssh-agent process(es)"
  else
    # No working stored agent, clean up all
    bc_log_debug "No working stored agent found, cleaning up all ssh-agent processes"
    local killed_count=0
    for pid in "${current_agents[@]}"; do
      if kill "$pid" 2>/dev/null; then
        bc_log_info "Cleaned up orphaned ssh-agent (PID: $pid)"
        ((killed_count++))
      fi
    done
    if [[ $killed_count -gt 0 ]]; then
      bc_log_success "Cleaned up $killed_count orphaned ssh-agent process(es)"
    else
      bc_log_debug "No ssh-agent processes found to clean up"
    fi
  fi
}

# Setup empty SSH agent for connection multiplexing
bc_setup_ssh_agent() {
  local agent_file="${1:-$HOME/.ssh-agent-info}"
  
  bc_log_debug "Setting up empty SSH agent for connection multiplexing"
  
  # Try to find and load existing agent info first
  if [[ -f "$agent_file" ]]; then
    bc_log_debug "Found existing agent info file, attempting to reuse"
    source "$agent_file" >/dev/null 2>&1
    
    # Check if the loaded agent is accessible
    ssh-add -l >/dev/null 2>&1
    local ssh_status=$?
    
    if [[ $ssh_status -eq 2 ]]; then
      bc_log_debug "Stored agent not accessible, removing stale file and starting new agent"
      rm -f "$agent_file"
      bc_start_ssh_agent "$agent_file"
    else
      bc_log_debug "Reusing existing agent (status: $ssh_status)"
    fi
  else
    bc_log_debug "No agent info file found, starting new agent"
    bc_start_ssh_agent "$agent_file"
  fi
  
  # Set up cleanup on exit for interactive shells
  if [[ $- == *i* ]]; then
    bc_cleanup_ssh_agent_on_exit() {
      if [[ -f "$agent_file" && -n "$SSH_AGENT_PID" ]]; then
        local stored_pid
        stored_pid=$(grep "SSH_AGENT_PID=" "$agent_file" 2>/dev/null | cut -d'=' -f2 | tr -d ';')
        if [[ "$stored_pid" == "$SSH_AGENT_PID" ]]; then
          rm -f "$agent_file"
        fi
      fi
    }
    trap bc_cleanup_ssh_agent_on_exit EXIT
  fi
}

# Configuration validation function
bc_validate_config() {
  local issues=0
  
  bc_log_info "Config Validation"
  
  # Check BASH_CONFIG_DIR
  if [[ -n "${BASH_CONFIG_DIR:-}" && -d "$BASH_CONFIG_DIR" ]]; then
    bc_log_success "Config directory found: $BASH_CONFIG_DIR"
  else
    bc_log_error "Config directory missing or not set: ${BASH_CONFIG_DIR:-'(not set)'}"
    ((issues++))
  fi
  
  # Check specialization file exists
  if [[ -n "${BASH_SPECIALISATION:-}" ]]; then
    local spec_file="$BASH_CONFIG_DIR/specialisations/bashrc_$BASH_SPECIALISATION"
    if [[ -f "$spec_file" ]]; then
      bc_log_success "Specialisation file found: $spec_file"
    else
      bc_log_error "Specialisation file missing: $spec_file"
      ((issues++))
    fi
  else
    bc_log_info "No specialisation set"
  fi
  
  # Check fastfetch config
  if [[ -n "${FASTFETCH_CONFIG:-}" ]]; then
    if [[ -f "$FASTFETCH_CONFIG" ]]; then
      bc_log_success "Fastfetch config found: $FASTFETCH_CONFIG"
    else
      bc_log_error "Fastfetch config missing: $FASTFETCH_CONFIG"
      ((issues++))
    fi
  fi
  
  # Check fastfetch binary
  if [[ -n "${FASTFETCH_BIN:-}" ]]; then
    if command -v "$FASTFETCH_BIN" &>/dev/null; then
      bc_log_success "Fastfetch binary found: $FASTFETCH_BIN"
    else
      bc_log_error "Fastfetch binary not executable: $FASTFETCH_BIN"
      ((issues++))
    fi
  fi
  
  # Check secrets file
  local secrets_file="$BASH_CONFIG_DIR/secrets/bash_secrets.sh"
  if [[ -f "$secrets_file" ]]; then
    bc_log_success "Secrets file found"
  else
    bc_log_warn "No secrets file (this may be intentional)"
  fi
  
  # Check SSH configuration
  if bc_check_ssh_config silent >/dev/null 2>&1; then
    bc_log_success "SSH config properly configured"
  else
    bc_log_warn "SSH config issues detected (run 'ssh-setup' to fix)"
  fi
  
  # Check SSH key if set
  if [[ -n "${DIAMOND_GITHUB_KEY:-}" ]]; then
    if [[ -f "$DIAMOND_GITHUB_KEY" ]]; then
      bc_log_success "SSH key file found: $DIAMOND_GITHUB_KEY"
    else
      bc_log_error "SSH key file missing: $DIAMOND_GITHUB_KEY"
      ((issues++))
    fi
  fi
  
  # Check history configuration
  if [[ -n "${HISTFILE:-}" ]]; then
    if [[ -f "$HISTFILE" ]]; then
      bc_log_success "History file found: $HISTFILE"
      local hist_size
      hist_size=$(wc -l < "$HISTFILE" 2>/dev/null || echo "0")
      bc_log_info "History contains $hist_size commands"
    else
      bc_log_warn "History file path set but file doesn't exist: $HISTFILE"
    fi
  fi
  
  if [[ $issues -eq 0 ]]; then
    bc_log_success "Configuration looks good!"
    return 0
  else
    bc_log_error "Found $issues issue(s)"
    return 1
  fi
}

# Display configuration information
bc_info() {
  echo -e "${BC_COLOR_CYAN}📋 Bash Configuration Information:${BC_COLOR_RESET}"
  echo -e "  ${BC_COLOR_BLUE}Version:${BC_COLOR_RESET} ${BASH_CONFIG_VERSION:-'unknown'}"
  echo -e "  ${BC_COLOR_BLUE}Directory:${BC_COLOR_RESET} ${BASH_CONFIG_DIR:-'not set'}"
  echo -e "  ${BC_COLOR_BLUE}Specialisation:${BC_COLOR_RESET} ${BASH_SPECIALISATION:-'none'}"
  echo -e "  ${BC_COLOR_BLUE}Host:${BC_COLOR_RESET} $(hostname)"
  echo -e "  ${BC_COLOR_BLUE}User:${BC_COLOR_RESET} $USER"
  [[ -n "${FASTFETCH_BIN:-}" ]] && echo -e "  ${BC_COLOR_BLUE}Fastfetch:${BC_COLOR_RESET} $FASTFETCH_BIN"
  [[ -n "${FASTFETCH_CONFIG:-}" ]] && echo -e "  ${BC_COLOR_BLUE}Fastfetch Config:${BC_COLOR_RESET} $FASTFETCH_CONFIG"
  
  # Show SSH agent status
  if ssh-add -l >/dev/null 2>&1; then
    local key_count
    key_count=$(ssh-add -l 2>/dev/null | wc -l)
    echo -e "  ${BC_COLOR_BLUE}SSH Agent:${BC_COLOR_RESET} ${BC_COLOR_GREEN}Active${BC_COLOR_RESET} (${key_count} key(s) loaded)"
  else
    echo -e "  ${BC_COLOR_BLUE}SSH Agent:${BC_COLOR_RESET} ${BC_COLOR_YELLOW}Inactive${BC_COLOR_RESET}"
  fi
  
  # Show history status
  if [[ -n "${HISTFILE:-}" ]]; then
    if [[ -f "$HISTFILE" ]]; then
      local hist_size
      hist_size=$(wc -l < "$HISTFILE" 2>/dev/null || echo "0")
      echo -e "  ${BC_COLOR_BLUE}History:${BC_COLOR_RESET} ${BC_COLOR_GREEN}Unified${BC_COLOR_RESET} ($hist_size commands)"
    else
      echo -e "  ${BC_COLOR_BLUE}History:${BC_COLOR_RESET} ${BC_COLOR_YELLOW}Local only${BC_COLOR_RESET}"
    fi
  else
    echo -e "  ${BC_COLOR_BLUE}History:${BC_COLOR_RESET} ${BC_COLOR_YELLOW}Default${BC_COLOR_RESET}"
  fi
}

# Toggle debug logging
bc_debug_toggle() {
  if [[ "${BASH_CONFIG_DEBUG:-}" == "true" ]]; then
    export BASH_CONFIG_DEBUG="false"
    bc_log_info "Debug logging disabled"
  else
    export BASH_CONFIG_DEBUG="true"
    bc_log_info "Debug logging enabled"
    bc_log_debug "This is a debug message example"
  fi
}