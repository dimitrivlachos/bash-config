# Colored logging functions
# Color codes for consistent messaging
BC_COLOR_RED='\033[0;31m'
BC_COLOR_GREEN='\033[0;32m'
BC_COLOR_YELLOW='\033[1;33m'
BC_COLOR_BLUE='\033[0;34m'
BC_COLOR_CYAN='\033[0;36m'
BC_COLOR_GRAY='\033[0;37m'
BC_COLOR_RESET='\033[0m'

# Logging functions with colors
bc_log_error() {
  echo -e "${BC_COLOR_RED}❌ [ERROR]${BC_COLOR_RESET} $*" >&2
}

bc_log_warn() {
  echo -e "${BC_COLOR_YELLOW}⚠️  [WARN]${BC_COLOR_RESET} $*" >&2
}

bc_log_info() {
  echo -e "${BC_COLOR_BLUE}ℹ️  [INFO]${BC_COLOR_RESET} $*" >&2
}

bc_log_success() {
  echo -e "${BC_COLOR_GREEN}✅ [SUCCESS]${BC_COLOR_RESET} $*" >&2
}

bc_log_debug() {
  [[ "${BASH_CONFIG_DEBUG:-}" == "true" ]] && echo -e "${BC_COLOR_GRAY}🔍 [DEBUG]${BC_COLOR_RESET} $*" >&2
}

# Local activate helper
mae() {
  local env_name="${1:-ENV}"
  local env_path=""

  if [ -d "./$env_name" ]; then
    env_path="$(pwd)/$env_name"
  elif [ -d "../$env_name" ]; then
    env_path="$(cd .. && pwd)/$env_name"
  else
    bc_log_error "No environment '$env_name' found in current or parent directory."
    return 1
  fi

  if command -v micromamba &>/dev/null; then
    micromamba activate "$env_path"
  elif command -v mamba &>/dev/null; then
    mamba activate "$env_path"
  else
    bc_log_error "Neither micromamba nor mamba found in PATH."
    return 1
  fi
}

# fastfetch wrapper that allows specialisations to override binary and config
bc_ff() {
  local ff_bin="${FASTFETCH_BIN:-fastfetch}" # Use override if set, otherwise system
  local ff_config="${FASTFETCH_CONFIG:-}"

  # Check if fastfetch is installed
  if command -v "$ff_bin" &>/dev/null; then
    # Check if config file is set and exists
    if [[ -n "$ff_config" && -f "$ff_config" ]]; then
      # Run fastfetch with the specified config
      "$ff_bin" --config "$ff_config" 2>/dev/null
    else
      # Run fastfetch without a config file
      "$ff_bin" 2>/dev/null
    fi
  else
    # Echo error to stderr (>&2)
    # and return non-zero exit code to indicate failure
    bc_log_error "[fastfetch] binary not found: $ff_bin"
    return 1
  fi
}

# Backward compatibility alias
ff() { bc_ff "$@"; }

# SSH agent management functions

# Check if a specific SSH key is loaded in the agent
bc_is_ssh_key_loaded() {
  local key_file="$1"
  if [[ -z "$key_file" || ! -f "$key_file" ]]; then
    return 1
  fi
  
  local key_fingerprint
  key_fingerprint=$(ssh-keygen -lf "$key_file" 2>/dev/null | awk '{print $2}')
  [[ -n "$key_fingerprint" ]] && ssh-add -l 2>/dev/null | grep -q "$key_fingerprint"
}

# Start a new SSH agent and save info to file
bc_start_ssh_agent() {
  local agent_file="$1"
  eval "$(ssh-agent -s)" >&2
  echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK; export SSH_AUTH_SOCK;" > "$agent_file"
  echo "SSH_AGENT_PID=$SSH_AGENT_PID; export SSH_AGENT_PID;" >> "$agent_file"
}

# Setup empty SSH agent for connection multiplexing
bc_setup_ssh_agent() {
  local agent_file="${1:-$HOME/.ssh-agent-info}"
  
  bc_log_debug "Setting up empty SSH agent for connection multiplexing"
  
  # Try to find and load existing agent info first
  if [[ -f "$agent_file" ]]; then
    bc_log_debug "Found existing agent info file, attempting to reuse"
    source "$agent_file" >/dev/null 2>&1
    
    # Check if the loaded agent is accessible
    ssh-add -l >/dev/null 2>&1
    local ssh_status=$?
    
    if [[ $ssh_status -eq 2 ]]; then
      bc_log_debug "Stored agent not accessible, removing stale file and starting new agent"
      rm -f "$agent_file"
      bc_start_ssh_agent "$agent_file"
    else
      bc_log_debug "Reusing existing agent (status: $ssh_status)"
    fi
  else
    bc_log_debug "No agent info file found, starting new agent"
    bc_start_ssh_agent "$agent_file"
  fi
  
  # Set up cleanup on exit for interactive shells
  if [[ $- == *i* ]]; then
    bc_cleanup_ssh_agent_on_exit() {
      if [[ -f "$agent_file" && -n "$SSH_AGENT_PID" ]]; then
        local stored_pid
        stored_pid=$(grep "SSH_AGENT_PID=" "$agent_file" 2>/dev/null | cut -d'=' -f2 | tr -d ';')
        if [[ "$stored_pid" == "$SSH_AGENT_PID" ]]; then
          rm -f "$agent_file"
        fi
      fi
    }
    trap bc_cleanup_ssh_agent_on_exit EXIT
  fi
}

# Manual cleanup function for orphaned SSH agents (use when needed)
bc_cleanup_ssh_agents() {
  local agent_file="${1:-$HOME/.ssh-agent-info}"
  local current_agents
  local force="${2:-false}"
  
  bc_log_info "Manually cleaning up SSH agents"
  
  # Get all running ssh-agent processes for this user
  mapfile -t current_agents < <(pgrep -u "$USER" ssh-agent 2>/dev/null)
  
  if [[ ${#current_agents[@]} -eq 0 ]]; then
    bc_log_info "No ssh-agent processes found"
    return 0
  fi
  
  # Get the PID from our agent file if it exists
  local stored_pid=""
  if [[ -f "$agent_file" ]]; then
    stored_pid=$(grep "SSH_AGENT_PID=" "$agent_file" 2>/dev/null | cut -d'=' -f2 | cut -d';' -f1 | tr -d ' ')
  fi
  
  # Get current agent PID from environment
  local current_pid="${SSH_AGENT_PID:-}"
  
  local killed_count=0
  for pid in "${current_agents[@]}"; do
    local should_kill=false
    
    if [[ "$force" == "true" ]]; then
      should_kill=true
      bc_log_debug "Force mode: killing agent PID $pid"
    elif [[ -n "$stored_pid" && "$pid" == "$stored_pid" ]]; then
      should_kill=true
      bc_log_debug "Killing stored agent PID $pid"
    elif [[ -n "$current_pid" && "$pid" == "$current_pid" ]]; then
      should_kill=true
      bc_log_debug "Killing current session agent PID $pid"
    elif [[ -z "$stored_pid" && -z "$current_pid" ]]; then
      # If we have no reference agents, only kill if there's exactly one
      if [[ ${#current_agents[@]} -eq 1 ]]; then
        should_kill=true
        bc_log_debug "Single orphaned agent found, killing PID $pid"
      else
        bc_log_warn "Multiple agents found but no reference - skipping PID $pid (use force mode to kill all)"
      fi
    else
      bc_log_debug "Skipping agent PID $pid (potentially in use by another session)"
    fi
    
    if [[ "$should_kill" == "true" ]]; then
      if kill "$pid" 2>/dev/null; then
        bc_log_info "Cleaned up ssh-agent (PID: $pid)"
        ((killed_count++))
      fi
    fi
  done
  
  # Only remove the agent info file if we killed the stored agent
  if [[ -f "$agent_file" && -n "$stored_pid" ]]; then
    local agent_still_running=false
    for pid in "${current_agents[@]}"; do
      if [[ "$pid" == "$stored_pid" ]] && kill -0 "$pid" 2>/dev/null; then
        agent_still_running=true
        break
      fi
    done
    
    if [[ "$agent_still_running" == "false" ]]; then
      rm -f "$agent_file"
      bc_log_debug "Removed agent info file"
    fi
  fi
  
  if [[ $killed_count -gt 0 ]]; then
    bc_log_success "Cleaned up $killed_count ssh-agent process(es)"
  else
    bc_log_warn "No ssh-agent processes were cleaned up"
    if [[ ${#current_agents[@]} -gt 0 ]]; then
      bc_log_info "Found ${#current_agents[@]} agent(s) that appear to be in use"
      bc_log_info "Use 'bc_cleanup_ssh_agents \"$agent_file\" force' to kill all agents"
    fi
  fi
}

# Add a safer wrapper function
bc_cleanup_current_ssh_agent() {
  local agent_file="${1:-$HOME/.ssh-agent-info}"
  bc_cleanup_ssh_agents "$agent_file" false
}

# Add a force cleanup function with clear warning
bc_cleanup_all_ssh_agents() {
  local agent_file="${1:-$HOME/.ssh-agent-info}"
  bc_log_warn "This will kill ALL ssh-agent processes for user $USER"
  read -p "Are you sure? (y/N): " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    bc_cleanup_ssh_agents "$agent_file" true
  else
    bc_log_info "Cleanup cancelled"
  fi
}

# List all SSH agents and their status
bc_list_ssh_agents() {
  local agent_file="${1:-$HOME/.ssh-agent-info}"
  local current_agents
  
  bc_log_info "SSH Agent Status"
  
  # Get all running ssh-agent processes for this user
  mapfile -t current_agents < <(pgrep -u "$USER" ssh-agent 2>/dev/null)
  
  if [[ ${#current_agents[@]} -eq 0 ]]; then
    echo -e "  ${BC_COLOR_YELLOW}No ssh-agent processes found${BC_COLOR_RESET}"
    return 0
  fi
  
  # Get the PID from our agent file if it exists
  local stored_pid=""
  if [[ -f "$agent_file" ]]; then
    stored_pid=$(grep "SSH_AGENT_PID=" "$agent_file" 2>/dev/null | cut -d'=' -f2 | cut -d';' -f1 | tr -d ' ')
  fi
  
  # Get current agent PID from environment
  local current_pid="${SSH_AGENT_PID:-}"
  
  echo -e "  ${BC_COLOR_BLUE}Found ${#current_agents[@]} ssh-agent process(es):${BC_COLOR_RESET}"
  
  for pid in "${current_agents[@]}"; do
    local status_info=""
    local color="$BC_COLOR_GRAY"
    
    if [[ -n "$stored_pid" && "$pid" == "$stored_pid" ]]; then
      status_info=" (stored in $agent_file)"
      color="$BC_COLOR_GREEN"
    fi
    
    if [[ -n "$current_pid" && "$pid" == "$current_pid" ]]; then
      status_info="${status_info} (current session)"
      color="$BC_COLOR_GREEN"
    fi
    
    if [[ -z "$status_info" ]]; then
      status_info=" (potentially orphaned or from another session)"
      color="$BC_COLOR_YELLOW"
    fi
    
    echo -e "    ${color}PID $pid${status_info}${BC_COLOR_RESET}"
  done
  
  # Show current session info
  echo -e "  ${BC_COLOR_BLUE}Current session:${BC_COLOR_RESET}"
  if [[ -n "$SSH_AUTH_SOCK" ]]; then
    echo -e "    ${BC_COLOR_GREEN}SSH_AUTH_SOCK: $SSH_AUTH_SOCK${BC_COLOR_RESET}"
    if [[ -n "$SSH_AGENT_PID" ]]; then
      echo -e "    ${BC_COLOR_GREEN}SSH_AGENT_PID: $SSH_AGENT_PID${BC_COLOR_RESET}"
    else
      echo -e "    ${BC_COLOR_YELLOW}SSH_AGENT_PID: not set${BC_COLOR_RESET}"
    fi
    
    # Try to list loaded keys
    if ssh-add -l >/dev/null 2>&1; then
      local key_count
      key_count=$(ssh-add -l 2>/dev/null | wc -l)
      echo -e "    ${BC_COLOR_GREEN}Status: Active with $key_count key(s) loaded${BC_COLOR_RESET}"
    else
      echo -e "    ${BC_COLOR_YELLOW}Status: Socket exists but no keys loaded${BC_COLOR_RESET}"
    fi
  else
    echo -e "    ${BC_COLOR_RED}No SSH agent configured for this session${BC_COLOR_RESET}"
  fi
  
  # Show stored agent info
  if [[ -f "$agent_file" ]]; then
    echo -e "  ${BC_COLOR_BLUE}Stored agent info (${agent_file}):${BC_COLOR_RESET}"
    if [[ -n "$stored_pid" ]]; then
      if kill -0 "$stored_pid" 2>/dev/null; then
        echo -e "    ${BC_COLOR_GREEN}PID $stored_pid (running)${BC_COLOR_RESET}"
      else
        echo -e "    ${BC_COLOR_RED}PID $stored_pid (not running - stale file)${BC_COLOR_RESET}"
      fi
    else
      echo -e "    ${BC_COLOR_RED}Invalid agent file format${BC_COLOR_RESET}"
    fi
  else
    echo -e "  ${BC_COLOR_YELLOW}No stored agent info file${BC_COLOR_RESET}"
  fi
}

# SSH agent management help
bc_ssh_help() {
  echo -e "${BC_COLOR_CYAN}🔑 SSH Agent Management Help:${BC_COLOR_RESET}"
  echo
  echo -e "${BC_COLOR_BLUE}Available Functions:${BC_COLOR_RESET}"
  echo -e "  ${BC_COLOR_GREEN}bc_setup_ssh_agent [agent_file]${BC_COLOR_RESET}"
  echo -e "    Set up an empty SSH agent for connection multiplexing"
  echo -e "    Default agent file: ~/.ssh-agent-info"
  echo
  echo -e "  ${BC_COLOR_GREEN}bc_list_ssh_agents [agent_file]${BC_COLOR_RESET}"
  echo -e "    Show status of all SSH agents and current session info"
  echo
  echo -e "  ${BC_COLOR_GREEN}bc_is_ssh_key_loaded <key_file>${BC_COLOR_RESET}"
  echo -e "    Check if a specific SSH key is loaded in the current agent"
  echo
  echo -e "  ${BC_COLOR_GREEN}bc_cleanup_current_ssh_agent [agent_file]${BC_COLOR_RESET}"
  echo -e "    Safely clean up only the current session's SSH agent"
  echo
  echo -e "  ${BC_COLOR_GREEN}bc_cleanup_ssh_agents [agent_file] [force]${BC_COLOR_RESET}"
  echo -e "    Clean up SSH agents (selective by default, force=true for all)"
  echo
  echo -e "  ${BC_COLOR_GREEN}bc_cleanup_all_ssh_agents [agent_file]${BC_COLOR_RESET}"
  echo -e "    Force cleanup all SSH agents with confirmation prompt"
  echo
  echo -e "${BC_COLOR_BLUE}Examples:${BC_COLOR_RESET}"
  echo -e "  ${BC_COLOR_GRAY}# Set up agent and check status${BC_COLOR_RESET}"
  echo -e "  bc_setup_ssh_agent"
  echo -e "  bc_list_ssh_agents"
  echo
  echo -e "  ${BC_COLOR_GRAY}# Load a key and check if it's loaded${BC_COLOR_RESET}"
  echo -e "  ssh-add ~/.ssh/id_rsa"
  echo -e "  bc_is_ssh_key_loaded ~/.ssh/id_rsa"
  echo
  echo -e "  ${BC_COLOR_GRAY}# Clean up safely${BC_COLOR_RESET}"
  echo -e "  bc_cleanup_current_ssh_agent"
  echo
  echo -e "  ${BC_COLOR_GRAY}# Nuclear option (with confirmation)${BC_COLOR_RESET}"
  echo -e "  bc_cleanup_all_ssh_agents"
  echo
  echo -e "${BC_COLOR_BLUE}Environment Variables:${BC_COLOR_RESET}"
  echo -e "  ${BC_COLOR_YELLOW}SSH_AUTH_SOCK${BC_COLOR_RESET}: Socket file for SSH agent communication"
  echo -e "  ${BC_COLOR_YELLOW}SSH_AGENT_PID${BC_COLOR_RESET}: Process ID of the current SSH agent"
  echo
  echo -e "${BC_COLOR_BLUE}Notes:${BC_COLOR_RESET}"
  echo -e "  • The agent is set up for connection multiplexing, not key storage"
  echo -e "  • SSH keys are managed via symlinked portable SSH config"
  echo -e "  • Agent info is stored persistently across sessions"
  echo -e "  • Cleanup functions prioritize safety over convenience"
}

# Configuration validation function
bc_validate_config() {
  local issues=0
  
  bc_log_info "Config Validation"
  
  # Check BASH_CONFIG_DIR
  if [[ -n "${BASH_CONFIG_DIR:-}" && -d "$BASH_CONFIG_DIR" ]]; then
    bc_log_success "Config directory found: $BASH_CONFIG_DIR"
  else
    bc_log_error "Config directory missing or not set: ${BASH_CONFIG_DIR:-'(not set)'}"
    ((issues++))
  fi
  
  # Check specialization file exists
  if [[ -n "${BASH_SPECIALISATION:-}" ]]; then
    local spec_file="$BASH_CONFIG_DIR/specialisations/bashrc_$BASH_SPECIALISATION"
    if [[ -f "$spec_file" ]]; then
      bc_log_success "Specialisation file found: $spec_file"
    else
      bc_log_error "Specialisation file missing: $spec_file"
      ((issues++))
    fi
  else
    bc_log_info "No specialisation set"
  fi
  
  # Check fastfetch config
  if [[ -n "${FASTFETCH_CONFIG:-}" ]]; then
    if [[ -f "$FASTFETCH_CONFIG" ]]; then
      bc_log_success "Fastfetch config found: $FASTFETCH_CONFIG"
    else
      bc_log_error "Fastfetch config missing: $FASTFETCH_CONFIG"
      ((issues++))
    fi
  fi
  
  # Check fastfetch binary
  if [[ -n "${FASTFETCH_BIN:-}" ]]; then
    if command -v "$FASTFETCH_BIN" &>/dev/null; then
      bc_log_success "Fastfetch binary found: $FASTFETCH_BIN"
    else
      bc_log_error "Fastfetch binary not executable: $FASTFETCH_BIN"
      ((issues++))
    fi
  fi
  
  # Check secrets file
  local secrets_file="$BASH_CONFIG_DIR/secrets/bash_secrets.sh"
  if [[ -f "$secrets_file" ]]; then
    bc_log_success "Secrets file found"
  else
    bc_log_warn "No secrets file (this may be intentional)"
  fi
  
  # Check SSH configuration
  if bc_check_ssh_config silent >/dev/null 2>&1; then
    bc_log_success "SSH config properly configured"
  else
    bc_log_warn "SSH config issues detected (run 'ssh-setup' to fix)"
  fi
  
  # Check SSH key if set
  if [[ -n "${DIAMOND_GITHUB_KEY:-}" ]]; then
    if [[ -f "$DIAMOND_GITHUB_KEY" ]]; then
      bc_log_success "SSH key file found: $DIAMOND_GITHUB_KEY"
    else
      bc_log_error "SSH key file missing: $DIAMOND_GITHUB_KEY"
      ((issues++))
    fi
  fi
  
  # Check history configuration
  if [[ -n "${HISTFILE:-}" ]]; then
    if [[ -f "$HISTFILE" ]]; then
      bc_log_success "History file found: $HISTFILE"
      local hist_size
      hist_size=$(wc -l < "$HISTFILE" 2>/dev/null || echo "0")
      bc_log_info "History contains $hist_size commands"
    else
      bc_log_warn "History file path set but file doesn't exist: $HISTFILE"
    fi
  fi
  
  if [[ $issues -eq 0 ]]; then
    bc_log_success "Configuration looks good!"
    return 0
  else
    bc_log_error "Found $issues issue(s)"
    return 1
  fi
}

# Display configuration information
bc_info() {
  echo -e "${BC_COLOR_CYAN}📋 Bash Configuration Information:${BC_COLOR_RESET}"
  echo -e "  ${BC_COLOR_BLUE}Version:${BC_COLOR_RESET} ${BASH_CONFIG_VERSION:-'unknown'}"
  echo -e "  ${BC_COLOR_BLUE}Directory:${BC_COLOR_RESET} ${BASH_CONFIG_DIR:-'not set'}"
  echo -e "  ${BC_COLOR_BLUE}Specialisation:${BC_COLOR_RESET} ${BASH_SPECIALISATION:-'none'}"
  echo -e "  ${BC_COLOR_BLUE}Host:${BC_COLOR_RESET} $(hostname)"
  echo -e "  ${BC_COLOR_BLUE}User:${BC_COLOR_RESET} $USER"
  [[ -n "${FASTFETCH_BIN:-}" ]] && echo -e "  ${BC_COLOR_BLUE}Fastfetch:${BC_COLOR_RESET} $FASTFETCH_BIN"
  [[ -n "${FASTFETCH_CONFIG:-}" ]] && echo -e "  ${BC_COLOR_BLUE}Fastfetch Config:${BC_COLOR_RESET} $FASTFETCH_CONFIG"
  
  # Show SSH agent status
  if ssh-add -l >/dev/null 2>&1; then
    local key_count
    key_count=$(ssh-add -l 2>/dev/null | wc -l)
    echo -e "  ${BC_COLOR_BLUE}SSH Agent:${BC_COLOR_RESET} ${BC_COLOR_GREEN}Active${BC_COLOR_RESET} (${key_count} key(s) loaded)"
  else
    echo -e "  ${BC_COLOR_BLUE}SSH Agent:${BC_COLOR_RESET} ${BC_COLOR_YELLOW}Inactive${BC_COLOR_RESET}"
  fi
  
  # Show history status
  if [[ -n "${HISTFILE:-}" ]]; then
    if [[ -f "$HISTFILE" ]]; then
      local hist_size
      hist_size=$(wc -l < "$HISTFILE" 2>/dev/null || echo "0")
      echo -e "  ${BC_COLOR_BLUE}History:${BC_COLOR_RESET} ${BC_COLOR_GREEN}Unified${BC_COLOR_RESET} ($hist_size commands)"
    else
      echo -e "  ${BC_COLOR_BLUE}History:${BC_COLOR_RESET} ${BC_COLOR_YELLOW}Local only${BC_COLOR_RESET}"
    fi
  else
    echo -e "  ${BC_COLOR_BLUE}History:${BC_COLOR_RESET} ${BC_COLOR_YELLOW}Default${BC_COLOR_RESET}"
  fi
}

# Toggle debug logging
bc_debug_toggle() {
  if [[ "${BASH_CONFIG_DEBUG:-}" == "true" ]]; then
    export BASH_CONFIG_DEBUG="false"
    bc_log_info "Debug logging disabled"
  else
    export BASH_CONFIG_DEBUG="true"
    bc_log_info "Debug logging enabled"
    bc_log_debug "This is a debug message example"
  fi
}